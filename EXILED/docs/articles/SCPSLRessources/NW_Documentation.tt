<#@ template debug="true" hostspecific="false" language="C#" #>
<#@ assembly name="System" #>
<#@ assembly name="%EXILED_REFERENCES%\System.Core.dll" #>
<#@ assembly name="%EXILED_REFERENCES%\Mirror.dll" #>
<#@ assembly name="%EXILED_REFERENCES%\UnityEngine.CoreModule.dll" #>
<#@ assembly name="%EXILED_REFERENCES%\Assembly-CSharp-Publicized.dll" #>
<#@ assembly name="bin\Release\Exiled.API.dll" #>
<#@ assembly name="bin\Release\Exiled.Loader.dll" #>
<#@ import namespace="Exiled.API.Enums" #>
<#@ import namespace="Exiled.API.Extensions" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="PlayerStatsSystem" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="PlayerRoles" #>
<#@ output extension=".md" #>

---
title: NW Documentation
---

Last Update (<#= Exiled.Loader.AutoUpdateFiles.RequiredSCPSLVersion#>)

### Index

- [RoleType, Team, Side, LeadingTeam](#roletype-team-side-and-leadingteam)
- [Damage Handlers](#damagehandlers)
<#
try
{
    string response = string.Empty;

    // Load the assembly
    var assembly = typeof(BanPlayer).Assembly;
    Type[] types = null;
    try
    {
        types = assembly.GetTypes();
    }
    catch (ReflectionTypeLoadException e)
    {
        types = e.Types;
    }
    foreach (var type in types.Where(t => t != null).OrderBy(t => t.Name))
    {
        if (type.IsEnum && !type.IsGenericType)
        {
            WriteLine($"- [{type.Name}](#{type.Name.ToLower()})");
            response += $"\n### {type.Name}\n\n";
            response += $"<details><summary><b>{type.FullName}</b></summary>\n\n";
            response += $"```\n";

            foreach (var value in Enum.GetValues(type))
            {
                response += $" [{Convert.ToInt64(value)}] = {value.ToString()}\n";
            }
            response += "```\n\n</details>\n";
         }
    }
    WriteLine(response);
}
catch(Exception ex)
{
    WriteLine(ex?.ToString());
}
#>

### External resources

- [Available Colors (en.scpslgame.com)](https://en.scpslgame.com/index.php/Docs:Permissions#Colors)

## Resources

### RoleType, Team, Side and LeadingTeam

<details><summary> <b>Roles</b></summary>

```
| Id  | RoleTypeId     | Team             | Side             | LeadingTeam     |
|-----|----------------|------------------|------------------|-----------------|
<#= string.Join("\n",Enum.GetValues(typeof(RoleTypeId)).Cast<RoleTypeId>().ToList().OrderBy(x => x).Select(x => $"| {((int)x).ToString().PadRight(3)} | {x.ToString().PadRight(14)} | {RoleExtensions.GetTeam(x).ToString().PadRight(16)} | {RoleExtensions.GetSide(RoleExtensions.GetTeam(x)).ToString().PadRight(16)} | {RoleExtensions.GetLeadingTeam(RoleExtensions.GetTeam(x)).ToString().PadRight(16)}|"))#>
```

</details>



### DamageHandlers

<details><summary> <b>Damage Handlers</b></summary>

```md title="Latest Updated: <#= Exiled.Loader.AutoUpdateFiles.RequiredSCPSLVersion#>"
All available DamageHandlers

+ Symbol ':' literally means "inherits from"
* In C#, inheritance is a process in which one object acquires all the properties and behaviors of its parent object automatically.


<#
string alldamagehandler = string.Empty;

// Load the assembly
var assembly2 = typeof(BanPlayer).Assembly;
Type[] types2 = null;

try
{
    types2 = assembly2.GetTypes();
}
catch (ReflectionTypeLoadException e)
{
    types2 = e.Types;
}

try
{
    Type baseDamageHandler = typeof(PlayerStatsSystem.DamageHandlerBase);
    var damageHandlers =
    types2.Where(t =>
        t != null &&
        t.IsClass &&
        baseDamageHandler.IsAssignableFrom(t));

    WriteLine("- " + baseDamageHandler.FullName);
    PrintTree(baseDamageHandler, 1);

    void PrintTree(Type parent, int depth)
    {
        var children = types2
            .Where(t => t != null && t.BaseType == parent)
            .OrderBy(t => Count(t));

        foreach (var child in children)
        {
            // Print only concrete classes, or include abstract if you want
            WriteLine($"{new string(' ', depth * 2)}- {child.FullName} : {child.BaseType.FullName}, {string.Join<Type>(", ", child.GetInterfaces()).ToString()}");
                
            // Recurse to process children correctly
            PrintTree(child, depth + 1);
        }
    }

    int Count(Type parent)
    {
        var children = types2
            .Where(t => t != null && t.BaseType == parent);

        int count = 0;
        foreach (var child in children)
        {
            count -= 1 + Count(child);
        }
        return count;
    }

}
catch (Exception ex)
{
    WriteLine(ex.ToString());
}
#>
```
</details>